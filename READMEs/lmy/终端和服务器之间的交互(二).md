# 终端和服务器之间的交互(二)

[TOC]

## 背景

上上周，我成功实现了树莓派上的捕获线程，然后投身到考试复习工作中，现在回到项目，完成了服务器端的通信部分

## 设计过程

之前我们对这个功能想过很多方式，一开始决定使用Python，后来考虑到网页后台使用PHP，于是想使用PHP扩展，但是问题是学习周期比较长，经过讨论发现，其他组员中实现服务器端功能的时候想要使用PHPJavabridge，那么我认为只要使用Java控制就可以了，虽然通信协议的定义使用的是C++的结构体，但是通过Java native方法就可以解决问题，而且我有相关的开发经验

服务器端的功能设计和终端相对应：

- 通知终端开始、结束录制和发送
- 检查终端的状态

明确了这些，相关的施工就可以开始了

## Java调用接口设计

Java接口作为一个类，应该具有什么样的功能？我们这里考虑的是让一个对象代表一个终端的控制方式，初始化的过程指定IP和端口号来确定一个终端的身份，然后使用没有参数的stop、start以及query函数完成停止、启动录制和状态查询的功能，具体实现如下：

```java
public class Pilib {
	static {
		System.loadLibrary("pilib");
	}

	public final static int STAT_STARTED = 0;
	public final static int STAT_STOPED = 1;
	public final static int STAT_OFFLIINE = 2;

	private static final int RET_SUCCESS = 0;
	private static final int RET_FAILED = -1;
	private static int connCnt = 0;

	private int status;
	private String ip;
	private int port;

	/**
	 * 初始化C++部分的全局变量
	 * @return 成功？
	 */
	private static native int lib_init();
	/**
	 * 用于启动和停止树莓派的函数
	 * @return 调用是否成功
	 */
	private static native int lib_startPi(String ip, int port);
	private static native int lib_stopPi(String ip, int port);

	/**
	 * 这个函数用于检查树莓派状态
	 * @return 状态
	 */
	private static native int lib_queryPi(String ip, int port);

	public Pilib(String piip, int piport) {
		ip = piip;
		port = piport;
		status = STAT_OFFLIINE;
		if(connCnt++ == 0) {
			lib_init();
		}
	}

	public void startPi(){
		int res = lib_startPi(ip, port);
		while(res == RET_FAILED) try{
			Thread.sleep(1000);
			res = lib_startPi(ip, port);
		} catch (InterruptedException e) {
			System.err.println("Sleep interrupted");
			e.printStackTrace();
			return;
		}
		status = STAT_STARTED;
	}

	public void stopPi() {
		int res = lib_stopPi(ip, port);
		while(res == RET_FAILED) try{
			Thread.sleep(1000);
			res = lib_stopPi(ip, port);
		}catch (InterruptedException e){
			System.err.println("Sleep interrupted");
			e.printStackTrace();
			return;
		}
		status = STAT_STOPED;
	}

	public int getStatus(){return status;}

	public void updateStatus() {
		status = lib_queryPi(ip, port);
	}

}
```

这里的设计思想主要是让native方法的实现尽量简单，主要还是靠Java，使用C++实现的本地方法仅仅完成传输工作，通过Java比较完善的异常机制来报告和处理异常情况

对应生成的头文件

```C++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Pilib */

#ifndef _Included_Pilib
#define _Included_Pilib
#ifdef __cplusplus
extern "C" {
#endif
#undef Pilib_STAT_STARTED
#define Pilib_STAT_STARTED 0L
#undef Pilib_STAT_STOPED
#define Pilib_STAT_STOPED 1L
#undef Pilib_STAT_OFFLIINE
#define Pilib_STAT_OFFLIINE 2L
#undef Pilib_RET_SUCCESS
#define Pilib_RET_SUCCESS 0L
#undef Pilib_RET_FAILED
#define Pilib_RET_FAILED -1L
/*
 * Class:     Pilib
 * Method:    lib_init
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_Pilib_lib_1init
  (JNIEnv *, jclass);

/*
 * Class:     Pilib
 * Method:    lib_startPi
 * Signature: (Ljava/lang/String;I)I
 */
JNIEXPORT jint JNICALL Java_Pilib_lib_1startPi
  (JNIEnv *, jclass, jstring, jint);

/*
 * Class:     Pilib
 * Method:    lib_stopPi
 * Signature: (Ljava/lang/String;I)I
 */
JNIEXPORT jint JNICALL Java_Pilib_lib_1stopPi
  (JNIEnv *, jclass, jstring, jint);

/*
 * Class:     Pilib
 * Method:    lib_queryPi
 * Signature: (Ljava/lang/String;I)I
 */
JNIEXPORT jint JNICALL Java_Pilib_lib_1queryPi
  (JNIEnv *, jclass, jstring, jint);

#ifdef __cplusplus
}
#endif
#endif
```

## C++本地方法实现

本地方法的实现尽量从简，我们设计的让Java完成可靠性的主要保障，没有反馈的函数过程直接发送，有反馈的过程原地等待反馈具体实现如下

```C++
#include "trans.h"
#include "Pilib.h"
#include <iostream>
#include <assert.h>

#define SERVER_PORT 16000
#define FB_TIMEO 10
#define FAIL_TRY 3

static int sockfd = -1;

/**
  * 初始化套接字描述符,将就是简单的函数转发
  */
JNIEXPORT jint JNICALL Java_Pilib_lib_1init
  (JNIEnv * env, jclass cls)
{
	sockfd = init_udp_socket(SERVER_PORT);
	std::cout << "sockfd is " << sockfd << std::endl;
}

/**
  * 启动树莓派,就是发送一个启动控制信号,然后等待确认
  */
JNIEXPORT jint JNICALL Java_Pilib_lib_1startPi
  (JNIEnv * env , jclass cls, jstring jip, jint jport)
{
	const char* ip = env->GetStringUTFChars(jip, 0);
	const int port = jport;

	assert(sockfd != -1);

	CntlMsg msg_to_send(CTL_START);

	//发送消息
	std::cout << "sending start msg to "<< ip << " : " << port << std::endl;
	int res = send_msg(sockfd, ip, port, &msg_to_send);

	//释放资源
	env->ReleaseStringUTFChars(jip, ip);
	return res;
}

/**
  * 这个和上面差不多,就是发送内容有区别
  */
JNIEXPORT jint JNICALL Java_Pilib_lib_1stopPi
  (JNIEnv *env , jclass cls, jstring jip, jint jport)
{
	//格式转换
	const char* ip = env->GetStringUTFChars(jip, 0);
	const int port = jport;

	assert(sockfd != -1);

	CntlMsg msg_to_send(CTL_STOP);

	//发送消息
	std::cout << "sending stop msg to "<< ip << " : " << port << std::endl;
	int res = send_msg(sockfd, ip, port, &msg_to_send);

	//释放资源
	env->ReleaseStringUTFChars(jip, ip);
	return res;
}

JNIEXPORT jint JNICALL Java_Pilib_lib_1queryPi
  (JNIEnv * env, jclass cls, jstring jip, jint jport)
{
	const char* ip = env->GetStringUTFChars(jip, 0);
	const int port = jport;

	char* feedback_ip = new char[16];
	int feedback_port = 0;

	assert(sockfd != -1);

	CntlMsg msg_to_send(CTL_STATUS);
	StatusMsg q_res(STAT_OFFLINE);
	FeedBackMsg conf(FB_CONFIRM);
	FeedBackMsg rej(FB_REJECT);

	//尝试发送几次,不成功就返回错误
	int try_count = FAIL_TRY;
	bool tsudzuke = true; //是否继续循环

	while(tsudzuke)
	{
		std::cout << "sending status msg to "<< ip << " : " << port << std::endl;
		send_msg(sockfd, ip, port, &msg_to_send);
		recv_msg(sockfd, feedback_ip, &feedback_port, &q_res, FB_TIMEO);

		if(q_res.status != STAT_OFFLINE)
		{//如果收到消息
			if(0 == strcmp(feedback_ip, ip) && feedback_port == port)
			{
				send_msg(sockfd, ip, port, &conf);
				tsudzuke = false;	//还是需要的机器发送的,确认结束
			}
			else
				send_msg(sockfd, feedback_ip, feedback_port, &rej);//不是需要机器发送的,拒绝信息
		} else if(try_count--) {
			tsudzuke = false;	//计数结束,认为没收到
		}
	}


	env->ReleaseStringUTFChars(jip, ip);
	delete feedback_ip;
	return q_res.status;
}

```

## 测试代码

当然，为了证明实现的可靠性，相关的测试不能没有

```java

public class srvTest {

	public static void main(String[] args) {

		Pilib lib = new Pilib("127.0.0.1", 8000);

		System.out.println("Init Complete...");

		lib.updateStatus();
		System.out.printf("Current status is %d\n", lib.getStatus());

		lib.startPi();
		System.out.println("Pi started...");
		try {
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		lib.updateStatus();
		System.out.printf("Current status is %d\n", lib.getStatus());
		lib.stopPi();
		System.out.println("Pi stopped");
	}
}

```

运行结果

## 小结

可靠性可能还需要进一步保障